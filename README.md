# Тестовое задание:

### Нужно реализовать MVC архитектурный паттерн на C++. В рамках приложения аутентификации (нужно предложить пользователю ввести пару логин пароль и, проверив, вывести сообщение об успехе-неуспехе).

- Платформы: STM32, Linux
- RTOS: FreeRTOS

**Требования:**

Для решения тестового задания код должен быть кросс-платформенным сборка основного таргета под OS Linux и arm gcc компилятор. Среда разработки на усмотрение разработчика. Очень круто будет иметь 2й билд таргет в виде GUI аппликейшна под линукс.

STM32 имеет ограниченные ресурсы - RAM/FLASH - код должен эти ограничения учитывать. В любой момент времени должна быть возможность узнать занятый объём динамической памяти и степень фрагментации. Универсальное решение не требуется (достаточно, чтобы такой контроль памяти применялся в отношении, например, конкретных классов). Можно использовать Heap механизм из FreeRTOS.

Графический интерфейс делать нужно на базе библиотеки LVGL. Весь UI должен выполняться в отдельном процессе FreeRTOS.

Аутентификационные данные хранить во флеше (файл в линуксе). Плюсом будет реализация счетчика попыток ввода пароля c блокировкой аккаунта при превышении лимита ошибок. 

Решение должно быть представлено в виде git-репозитория (github, gitlab, bitbucket). Наличие промежуточных коммитов с комментариями о ходе разработки приветствуется.

## Решение
- **app_tasks.cpp**
  
  Создаются две задачи: *task_lvgl* и *task_mvc* с более высоким приоритетом, чем *task_lvgl*.
    - ***task_lvgl*** Осуществляет отрисовку пользовательского интерфейса и обработку событий. В обработчике события нажатия на кнопку "Log in" вызывается функция *update_log_pass()*, и она в свою очередь уведомляет задачу *task_mvc*, чтобы она начала выполнение. В данном случае, переключение на работу задачи *task_mvc* осуществляется с помощью механизма нотификаций.
    - ***task_mvc*** Создает локально объекты *model*, *view*, *controller* и ожидает уведомление с помощью механизма нотификаций. После получения уведомления, обрабатывает введенные *username* и *password* и показывает результат на экране.

  Взаимодействие с LVGL (вывод текстовых сообщений, изменение состояния текстовых полей и кнопок) осуществлятся с помощью мьютексов.

  В программе нет необходимости использовать *unique_ptr* или *shared_ptr*, т.к. не происходит динамического выделения памяти.

## Блок-схема программы:

```mermaid
flowchart TD
    A([Начало main]) --> B[Инициализация дисплея 
                            и у-ва ввода]
    B --> C[Создание задач 
            lvgl_thread и mvc_thread]

    A1([Начало lvgl_thread]) --> B1[Создание пользовательского 
                                    интерфейса]
    B1 --> C1[/start for\]
    C1 --> D1[lv_task_handler]
    D1 --> E1[Получение введенных username и password]
    E1 --> F1[Передача управления задаче 
                mvc_thread
                через механизм нотификации]
    F1 --> G1[\end for/]
    G1 --> C1

    A2([Начало mvc_thread]) --> B2[Читаем из памяти сохраненные 
                                    username и password]
    B2 --> C2[Создание объектов 
                model, view, controller]
    C2 --> D2[/start for\]
    D2 --> E2[Ожидание нотификации]
    E2 --> F2{Аутентификация 
                прошла успешно?}
    F2 --да--> G2[Привести интерфейс 
                    в исходное состояние]     
    F2 --нет--> H2[Процесс аутентификации]  
    H2 --> I2[\end for/]
    G2 --> I2[\end for/]
    I2 --> D2
```

## Диаграмма классов:

```mermaid
classDiagram
    class auth_model {
        - const char* f_username
        - const char* f_password
        - int f_counter
        - bool f_is_auth_succeed
        + auth_model(const char* username, const char* password)
        + int get_attempts_counter() const
        + bool is_auth_succeed() const
        - void authenticate(const char* username, const char* password)
        - void reset()
    }

    class observable {
        - std::vector<observer*> f_observers
        + void add_observer(observer* observer)
        # void notify_update() const
    }

    class auth_view {
        - auth_model& f_model
        + auth_view(auth_model& model)
        + void update() override
        - static void show_success_message()
        - static void show_failure_message(const int attempts)
        - static void set_profile_panel_mode(const panel_mode_t mode)
    }

    class observer {
        + virtual ~observer() = default
        + virtual void update() = 0
    }

    class auth_controller {
        - auth_model& f_model
        + auth_controller(auth_model& model)
        + void authenticate_user(const char* username, const char* password) const
        + void set_default_state() const
    }

    auth_model <|-- observable
    auth_view --|> observer
    auth_view --> auth_model
    auth_controller --> auth_model
```

## Использованные возможности C++11 и выше:

- **Class auth_model:**
    - Атрибут ***constexpr*** при использовании константных выражений и констант времени компиляции.
    - Использование переменных типа инициализирующего значения (ключевое слово ***auto*** в указании типа).
    - Использование ***override***-спецификатора позволяют убедиться на этапе компиляции что мы действительно переопределили функцию базового класса.
    - Использование спецификатора ***final*** запрещает наследование от текущего класса.
    - Использование ***explicit*** в объявлении конструктора для исключения неявных преобразований типов.
    - (C++17) Атрибут ***[[nodiscard]]*** для указания необходимости использования возвращаемого значения.

- **Class auth_view:**
    - Атрибут ***constexpr*** при использовании константных выражений и констант времени компиляции.
    - Использование переменных типа инициализирующего значения (ключевое слово ***auto*** в указании типа).
    - Использование ***override***-спецификатора позволяют убедиться на этапе компиляции что мы действительно переопределили функцию базового класса.
    - Использование спецификатора ***final*** запрещает наследование от текущего класса.
    - Использование ***перечисления со строгой типизацией*** (enum class panel_mode_t).
    - Использование ***explicit*** в объявлении конструктора для исключения неявных преобразований типов.
    - (C++17) ***Инициализация локальной переменной в if***.
 
- **Class auth_controller:**
    - Использование ***explicit*** в объявлении конструктора для исключения неявных преобразований типов.

- **observable.cpp**
    - Использование ***range-based for***.
    - Использование переменных типа инициализирующего значения (ключевое слово ***auto*** в указании типа).

- **app_tasks.cpp**
    - Использование **cписка инициализации** g_log_pass = { username, password }.
    - Использование ключевого слова ***nullptr*** для описания константы нулевого указателя.
    - Использование директивы ***using*** для создания псевдонима типа данных.

- **app.h, app.cpp**
    - Использование ***перечисления со строгой типизацией*** (enum class error_code_t).
    - (C++17) ***Инициализация локальной переменной в if***.

- **gui_app.h, gui_app.cpp**
    - Атрибут ***constexpr*** при использовании константных выражений и констант времени компиляции.
    - Использование переменных типа инициализирующего значения (ключевое слово ***auto*** в указании типа).
    - Использование ключевого слова ***nullptr*** для описания константы нулевого указателя.
    - (C++17) ***Инициализация локальной переменной в if***.
 
- **memory.h, memory.cpp**
    - Атрибут ***constexpr*** при использовании константных выражений и констант времени компиляции.
    - Использование переменных типа инициализирующего значения (ключевое слово ***auto*** в указании типа).
    - (C++17) ***Инициализация локальной переменной в if***.
 
- **static_string.h**
    - Атрибут ***constexpr*** при использовании константных выражений и констант времени компиляции.
    - Использование переменных типа инициализирующего значения (ключевое слово ***auto*** в указании типа).
    - Использование директивы ***using*** для создания псевдонима типа данных.
    - (C++17) Атрибут ***[[nodiscard]]*** для указания необходимости использования возвращаемого значения.

## Видео демонстрации работы

**Windows Simulator:**

[![WindowsSimulator](https://github.com/Makc711/LVGL_log_pass_LVGLv9.0.1/assets/40514121/68c06063-ada1-476f-a3ea-9761b7aadf88)](https://youtu.be/RQeSUsR3VE0)

------------------------------------------------------------------------------------------------------------

**Отладочная плата STM32F746G-DISCOVERY:**

[![Отладочная плата STM32F746G-DISCOVERY](https://github.com/Makc711/LVGL_log_pass_LVGLv9.0.1/assets/40514121/31481932-e74d-4112-a536-1be8f129f30a)](https://youtu.be/dROaekssqAs)
